# Challenge 8: CI-CD in AzureDevOps Yaml

[< Previous Challenge](./07-CD-in-Azure-DevOps-Classic.md) - **[Home](../README.md)** - [Next Challenge >](./09-privateaks.md)

## Introduction

In the previous two challenges, we created a build pipeline and a classic release.  Both of these require the user/develoepr to log into Azure DevOps in order to make changes to the build/deployment workflow.  However, a second method is also available in Azure DevOps.  This is to use a yaml pipeline, more specifically, a multi-stage yaml pipeline to handle both building and deploying.

Yaml is a descriptive syntax, similar to Json.  A yaml pipeline is a workflow file that is stored within your code repository.  Azure DevOps can then implement the workflow defined within the yaml file.  The benefit of this is that developers can alter the build without having to log into Azure DevOps.  The pipeline definition becomes part of your code base.

## Creating the Pipeline

From the pipelines menue in Azure DevOps, create a new pipeline.  Do not create a classic pipeline, but choose one of the others.  We are supplying the following starting sample for you, so you will want to replace the autogenerated pipeline with the below:

```
trigger:
# somthing here

resources:
- repo: self

variables:

  # Container registry service connection name
  dockerRegistryServiceConnection: 'connection name'
  kubernetesServiceConnection: 'connection name'
  # Other Variables go here.....

  # Agent VM image name
  vmImageName: 'ubuntu-latest'


stages:
- stage: Build
  displayName: Build stage
  jobs:
  - job: Build
    displayName: Build
    pool:
      vmImage: $(vmImageName)
    steps:

    # Steps go here

    # If you use a publish step, you can pick up the file in later stages, for example the
    # following publish step can be retrieved in the deploy stage with
    # $(Pipeline.Workspace)/dropapi/content-api-deploy-solution-sa.yml
    - publish: $(System.DefaultWorkingDirectory)/Student/Resources/Challenge 0/content-api/content-api-deploy-solution-sa.yml
      artifact: dropapi

    # More steps as the API and Web will need to be worked out separately
    - publish: $(System.DefaultWorkingDirectory)/Student/Resources/Challenge 0/content-web/content-web-deploy-solution-sa.yml
      artifact: dropweb

- stage: Deploy
  displayName: Deploy stage
  dependsOn: Build

  jobs:
  - deployment: Deploy
    displayName: Deploy
    pool:
      vmImage: $(vmImageName)
    environment: 'EnvironmentName'
    strategy:
      runOnce:
        deploy:
          steps:

            # Steps go here

```

But of course, the above is not fully complete.  This would not be a challenge if it was.  There are a couple of ways that you can determine the correct steps to use.  Syntactically, you can take a look at your previously created 'classic' pipelines, as each step has a "show yaml" button that will display the equivalent yaml for each step.  You will also need to decide if you want to use ACR Tasks or build the containers directly with docker on the build machines.  Docker is available on the supplied ubuntu machines.  Note that if you use Docker, you need to make sure that docker can authenticate to the Azure Container Registry.  This requires a new Docker service connection, which is created on the Service Connection page in Azure DevOps.  Note that the Azure Container Registry can have the admin account enabled, which will allow logins without RBAC.

Some tasks that you may want to use in your steps are:
* Docker2
* KubernetesManifest
* Publish
* AzureCLI2

Tasks can be discovered, and configured using the 'Assistant' button on the right of the yaml editing display within Azure DevOps

As with the previous challenge, let's focus on the Kubernetes Deployments, and leave the Kubernetes Service already running in the cluster.  Of course, if this was a real project you would handle both pieces.

## Success Criteria

1. You create a multi stage yaml pipeline that builds the application to your Azure Container Registry and then deploys it to your Kubernetes Cluster
2. Your pipeline should run as CI/CD and be triggered whenever your main branch is updated


## Reading:

[Azure DevOps Yaml Schema Reference](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devops&tabs=schema%2Cparameter-schema)

[Jobs in Azure DevOps Yaml Pipelines](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=azure-devops&tabs=yaml)

[Environments in Azure DevOps Pipelines](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/environments?view=azure-devops)

[Authentication to an Azure Container Registry](https://docs.microsoft.com/en-us/azure/container-registry/container-registry-authentication)